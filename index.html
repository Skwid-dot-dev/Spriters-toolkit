<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Sheet Splitter</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .panel {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        input, button {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        input[type="number"] {
            width: 80px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: bold;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .preview-area {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .sprite-sheet-container {
            flex: 1;
            min-width: 300px;
            position: relative;
        }
        .sprites-container {
            flex: 1;
            min-width: 300px;
            max-height: 600px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .sprite-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #f5f5f5;
        }
        .sprite-item canvas {
            max-width: 100%;
            image-rendering: pixelated;
        }
        .sprite-item .sprite-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        #spriteSheetCanvas {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            image-rendering: pixelated;
        }
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .download-all {
            margin-top: 10px;
        }
        .hint {
            font-size: 14px;
            color: #666;
            font-style: italic;
            margin-top: 5px;
        }
        .status {
            font-weight: bold;
            margin-top: 10px;
            color: #27ae60;
        }
        /* Add to your existing CSS */
.animation-panel {
    margin-top: 20px;
}

#animationPreview {
    margin-top: 10px;
    border: 1px solid #ddd;
    background: #fff;
    image-rendering: pixelated;
    max-width: 100%;
    height: auto;
}

.color-palette {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 5px;
    margin-top: 10px;
    padding: 10px;
    background: #fff;
    border-radius: 4px;
    border: 1px solid #ddd;
}

.color-swatch {
    width: 30px;
    height: 30px;
    border: 1px solid #ddd;
    cursor: pointer;
    border-radius: 4px;
}

.transform-tools {
    display: flex;
    gap: 10px;
    margin-top: 10px;
    flex-wrap: wrap;
}

.color-tools {
    margin-top: 20px;
}

.selected-color {
    border: 2px solid #3498db;
}
        
    </style>
</head>
<body>
    <h1>Sprite Sheet Splitter</h1>
    <p>Upload a sprite sheet and split it into individual sprites by specifying the dimensions of each sprite.</p>
    
    <div class="container">
        <div class="panel">
            <div class="controls">
                <div class="control-group">
                    <label for="spriteSheetInput">Upload Sprite Sheet:</label>
                    <input type="file" id="spriteSheetInput" accept="image/*">
                    <!-- Add after the existing preview panel -->
<div class="panel animation-panel">
    <h2>Animation Preview</h2>
    <div class="controls">
        <div class="control-group">
            <label for="frameStart">Start Frame:</label>
            <input type="number" id="frameStart" min="0" value="0">
        </div>
        <div class="control-group">
            <label for="frameEnd">End Frame:</label>
            <input type="number" id="frameEnd" min="0" value="0">
        </div>
        <div class="control-group">
            <label for="fps">FPS:</label>
            <input type="number" id="fps" min="1" value="12">
        </div>
        <button id="previewAnimation">Preview Animation</button>
        <button id="stopAnimation">Stop</button>
    </div>
    <canvas id="animationPreview"></canvas>
</div>

<div class="panel tools-panel">
    <h2>Sprite Tools</h2>
    <div class="transform-tools">
        <button id="flipH">Flip Horizontal</button>
        <button id="flipV">Flip Vertical</button>
        <button id="rotate90">Rotate 90°</button>
        <button id="rotate180">Rotate 180°</button>
        <button id="rotate270">Rotate 270°</button>
    </div>
    
    <div class="color-tools">
        <h3>Color Palette</h3>
        <button id="extractPalette">Extract Palette</button>
        <div id="colorPalette" class="color-palette"></div>
    </div>
</div>  
                </div>
                
                <div class="control-group">
                    <label for="spriteWidth">Sprite Width (px):</label>
                    <input type="number" id="spriteWidth" min="1" value="32">
                </div>
                
                <div class="control-group">
                    <label for="spriteHeight">Sprite Height (px):</label>
                    <input type="number" id="spriteHeight" min="1" value="32">
                </div>
                
                <div class="control-group">
                    <label for="spacing">Spacing (px):</label>
                    <input type="number" id="spacing" min="0" value="0">
                    <div class="hint">Space between sprites</div>
                </div>
                
                <div class="control-group">
                    <label for="padding">Padding (px):</label>
                    <input type="number" id="padding" min="0" value="0">
                    <div class="hint">Border inside each sprite</div>
                </div>
                
                <div class="control-group">
                    <label for="columns">Columns (optional):</label>
                    <input type="number" id="columns" min="0" value="0">
                    <div class="hint">Leave at 0 for auto-detection</div>
                </div>
                
                <div class="control-group">
                    <label>&nbsp;</label>
                    <button id="splitButton" disabled>Split Sprites</button>
                </div>
            </div>
            
            <div class="control-group">
                <label for="showGrid">
                    <input type="checkbox" id="showGrid" checked> Show Grid
                </label>
            </div>
        </div>
        
        <div class="panel">
            <h2>Preview</h2>
            <div class="preview-area">
                <div class="sprite-sheet-container">
                    <h3>Sprite Sheet</h3>
                    <canvas id="spriteSheetCanvas"></canvas>
                    <canvas id="gridOverlay" class="grid-overlay"></canvas>
                </div>
                
                <div class="sprites-output">
                    <h3>Individual Sprites</h3>
                    <div id="spritesContainer" class="sprites-container">
                        <p>Split sprites will appear here</p>
                    </div>
                    <button id="downloadAllButton" class="download-all" disabled>Download All Sprites</button>
                    <div id="status" class="status"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const spriteSheetInput = document.getElementById('spriteSheetInput');
        const spriteWidthInput = document.getElementById('spriteWidth');
        const spriteHeightInput = document.getElementById('spriteHeight');
        const spacingInput = document.getElementById('spacing');
        const paddingInput = document.getElementById('padding');
        const columnsInput = document.getElementById('columns');
        const showGridCheckbox = document.getElementById('showGrid');
        const splitButton = document.getElementById('splitButton');
        const downloadAllButton = document.getElementById('downloadAllButton');
        const spriteSheetCanvas = document.getElementById('spriteSheetCanvas');
        const gridOverlay = document.getElementById('gridOverlay');
        const spritesContainer = document.getElementById('spritesContainer');
        const statusElement = document.getElementById('status');
        
        let spriteSheet = null;
        let individualSprites = [];
        // Add these class definitions at the top of your script
class PaletteManager {
    constructor() {
        this.colors = [];
        this.maxColors = 32;
        this.selectedColor = null;
    }
    
    extractPalette(imageData) {
        const colorMap = new Map();
        
        for(let i = 0; i < imageData.data.length; i += 4) {
            const r = imageData.data[i];
            const g = imageData.data[i + 1];
            const b = imageData.data[i + 2];
            const a = imageData.data[i + 3];
            const colorKey = `rgba(${r},${g},${b},${a})`;
            
            colorMap.set(colorKey, (colorMap.get(colorKey) || 0) + 1);
        }
        
        // Sort colors by frequency
        this.colors = Array.from(colorMap.entries())
            .sort((a, b) => b[1] - a[1])
            .map(([color]) => color)
            .slice(0, this.maxColors);
            
        return this.colors;
    }
    
    renderPalette() {
        const palette = document.getElementById('colorPalette');
        palette.innerHTML = '';
        
        this.colors.forEach(color => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = color;
            swatch.addEventListener('click', () => this.selectColor(color, swatch));
            palette.appendChild(swatch);
        });
    }
    
    selectColor(color, swatch) {
        this.selectedColor = color;
        document.querySelectorAll('.color-swatch').forEach(s => 
            s.classList.remove('selected-color'));
        swatch.classList.add('selected-color');
    }
}

class AnimationPreview {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.frames = [];
        this.currentFrame = 0;
        this.isPlaying = false;
        this.fps = 12;
        this.animationId = null;
    }
    
    setFrames(frames) {
        this.frames = frames;
        this.currentFrame = 0;
        this.canvas.width = frames[0].width;
        this.canvas.height = frames[0].height;
    }
    
    play() {
        if (this.frames.length === 0) return;
        
        this.isPlaying = true;
        let lastTime = 0;
        const frameInterval = 1000 / this.fps;
        
        const animate = (timestamp) => {
            if (!this.isPlaying) return;
            
            if (timestamp - lastTime >= frameInterval) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.frames[this.currentFrame], 0, 0);
                
                this.currentFrame = (this.currentFrame + 1) % this.frames.length;
                lastTime = timestamp;
            }
            
            this.animationId = requestAnimationFrame(animate);
        };
        
        this.animationId = requestAnimationFrame(animate);
    }
    
    stop() {
        this.isPlaying = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        this.currentFrame = 0;
        if (this.frames.length > 0) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(this.frames[0], 0, 0);
        }
    }
}

// Initialize new components
const paletteManager = new PaletteManager();
const animationPreview = new AnimationPreview(document.getElementById('animationPreview'));

// Add event listeners for new functionality
document.getElementById('extractPalette').addEventListener('click', () => {
    if (!spriteSheet) return;
    
    const ctx = spriteSheetCanvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, spriteSheetCanvas.width, spriteSheetCanvas.height);
    paletteManager.extractPalette(imageData);
    paletteManager.renderPalette();
});

document.getElementById('previewAnimation').addEventListener('click', () => {
    const startFrame = parseInt(document.getElementById('frameStart').value);
    const endFrame = parseInt(document.getElementById('frameEnd').value);
    const fps = parseInt(document.getElementById('fps').value);
    
    if (startFrame >= 0 && endFrame < individualSprites.length && startFrame <= endFrame) {
        const frames = individualSprites
            .slice(startFrame, endFrame + 1)
            .map(sprite => {
                const img = new Image();
                img.src = sprite.dataURL;
                return img;
            });
            
        animationPreview.fps = fps;
        animationPreview.setFrames(frames);
        animationPreview.play();
    }
});

document.getElementById('stopAnimation').addEventListener('click', () => {
    animationPreview.stop();
});

// Transform tools event listeners
document.getElementById('flipH').addEventListener('click', () => {
    if (!spriteSheet) return;
    const flipped = SpriteTransformer.flip(spriteSheetCanvas, true);
    spriteSheetCanvas.getContext('2d').drawImage(flipped, 0, 0);
    drawGrid();
});

document.getElementById('flipV').addEventListener('click', () => {
    if (!spriteSheet) return;
    const flipped = SpriteTransformer.flip(spriteSheetCanvas, false);
    spriteSheetCanvas.getContext('2d').drawImage(flipped, 0, 0);
    drawGrid();
});

['90', '180', '270'].forEach(degrees => {
    document.getElementById(`rotate${degrees}`).addEventListener('click', () => {
        if (!spriteSheet) return;
        const rotated = SpriteTransformer.rotate(spriteSheetCanvas, parseInt(degrees));
        spriteSheetCanvas.getContext('2d').drawImage(rotated, 0, 0);
        drawGrid();
    });
});
        
        
        // Handle sprite sheet upload
        spriteSheetInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    spriteSheet = img;
                    renderSpriteSheet();
                    splitButton.disabled = false;
                    showGridCheckbox.checked = true;
                    drawGrid();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
        
        // Update grid when dimensions change
        [spriteWidthInput, spriteHeightInput, spacingInput, paddingInput, columnsInput].forEach(input => {
            input.addEventListener('change', drawGrid);
        });
        
        // Toggle grid visibility
        showGridCheckbox.addEventListener('change', function() {
            gridOverlay.style.display = this.checked ? 'block' : 'none';
        });
        
        // Split the sprite sheet into individual sprites
        splitButton.addEventListener('click', splitSpriteSheet);
        
        // Download all sprites as ZIP
        downloadAllButton.addEventListener('click', downloadAllSprites);
        
        // Render the sprite sheet on canvas
        function renderSpriteSheet() {
            if (!spriteSheet) return;
            
            const ctx = spriteSheetCanvas.getContext('2d');
            spriteSheetCanvas.width = spriteSheet.width;
            spriteSheetCanvas.height = spriteSheet.height;
            ctx.clearRect(0, 0, spriteSheetCanvas.width, spriteSheetCanvas.height);
            ctx.drawImage(spriteSheet, 0, 0);
            
            // Also resize the grid overlay
            gridOverlay.width = spriteSheet.width;
            gridOverlay.height = spriteSheet.height;
        }
        
        // Draw the grid overlay
        function drawGrid() {
            if (!spriteSheet) return;
            
            const spriteWidth = parseInt(spriteWidthInput.value) || 32;
            const spriteHeight = parseInt(spriteHeightInput.value) || 32;
            const spacing = parseInt(spacingInput.value) || 0;
            const padding = parseInt(paddingInput.value) || 0;
            const specifiedColumns = parseInt(columnsInput.value) || 0;
            
            const ctx = gridOverlay.getContext('2d');
            ctx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);
            
            // Calculate columns if not specified
            const columns = specifiedColumns || Math.floor(spriteSheet.width / (spriteWidth + spacing));
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            
            // Draw horizontal lines
            for (let y = 0; y <= spriteSheet.height; y += spriteHeight + spacing) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(spriteSheet.width, y);
                ctx.stroke();
            }
            
            // Draw vertical lines
            if (specifiedColumns > 0) {
                // If columns are specified, draw that many columns evenly spaced
                for (let x = 0; x <= spriteSheet.width; x += (spriteSheet.width / columns)) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, spriteSheet.height);
                    ctx.stroke();
                }
            } else {
                // Otherwise draw lines based on sprite width + spacing
                for (let x = 0; x <= spriteSheet.width; x += spriteWidth + spacing) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, spriteSheet.height);
                    ctx.stroke();
                }
            }
            
            // If padding is specified, draw inner rectangles
            if (padding > 0) {
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
                
                const rows = Math.floor(spriteSheet.height / (spriteHeight + spacing));
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < columns; col++) {
                        const x = col * (spriteWidth + spacing) + padding;
                        const y = row * (spriteHeight + spacing) + padding;
                        const innerWidth = spriteWidth - 2 * padding;
                        const innerHeight = spriteHeight - 2 * padding;
                        
                        ctx.strokeRect(x, y, innerWidth, innerHeight);
                    }
                }
            }
        }
        
        // Split the sprite sheet into individual sprites
        function splitSpriteSheet() {
            if (!spriteSheet) return;
            
            const spriteWidth = parseInt(spriteWidthInput.value) || 32;
            const spriteHeight = parseInt(spriteHeightInput.value) || 32;
            const spacing = parseInt(spacingInput.value) || 0;
            const padding = parseInt(paddingInput.value) || 0;
            const specifiedColumns = parseInt(columnsInput.value) || 0;
            
            // Calculate columns and rows
            const columns = specifiedColumns || Math.floor(spriteSheet.width / (spriteWidth + spacing));
            const rows = Math.floor(spriteSheet.height / (spriteHeight + spacing));
            
            // Clear previous sprites
            individualSprites = [];
            spritesContainer.innerHTML = '';
            
            // Create temporary canvas for extraction
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = spriteWidth - 2 * padding;
            tempCanvas.height = spriteHeight - 2 * padding;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Extract each sprite
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < columns; col++) {
                    const x = col * (spriteWidth + spacing) + padding;
                    const y = row * (spriteHeight + spacing) + padding;
                    const effectiveWidth = spriteWidth - 2 * padding;
                    const effectiveHeight = spriteHeight - 2 * padding;
                    
                    // Skip if outside image bounds
                    if (x + effectiveWidth > spriteSheet.width || y + effectiveHeight > spriteSheet.height) {
                        continue;
                    }
                    
                    // Extract sprite
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(
                        spriteSheet, 
                        x, y, effectiveWidth, effectiveHeight,
                        0, 0, tempCanvas.width, tempCanvas.height
                    );
                    
                    // Create sprite data
                    const spriteData = {
                        row,
                        col,
                        dataURL: tempCanvas.toDataURL('image/png'),
                        width: effectiveWidth,
                        height: effectiveHeight
                    };
                    
                    individualSprites.push(spriteData);
                    
                    // Create sprite preview
                    createSpritePreview(spriteData, row, col);
                }
            }
            
            // Enable download button
            downloadAllButton.disabled = individualSprites.length === 0;
            
            // Show status
            statusElement.textContent = `${individualSprites.length} sprites extracted`;
        }
        
        // Create and display a preview for a single sprite
        function createSpritePreview(spriteData, row, col) {
            const spriteDiv = document.createElement('div');
            spriteDiv.className = 'sprite-item';
            
            // Create canvas for sprite
            const canvas = document.createElement('canvas');
            canvas.width = spriteData.width;
            canvas.height = spriteData.height;
            const ctx = canvas.getContext('2d');
            
            // Draw sprite
            const img = new Image();
            img.onload = function() {
                ctx.drawImage(img, 0, 0);
            };
            img.src = spriteData.dataURL;
            
            // Add sprite index label
            const label = document.createElement('div');
            label.className = 'sprite-label';
            label.textContent = `Row ${row}, Col ${col}`;
            
            // Add download button for individual sprite
            const downloadBtn = document.createElement('button');
            downloadBtn.textContent = 'Download';
            downloadBtn.style.fontSize = '12px';
            downloadBtn.style.padding = '3px 6px';
            downloadBtn.style.marginTop = '5px';
            downloadBtn.addEventListener('click', () => {
                downloadSprite(spriteData, row, col);
            });
            
            spriteDiv.appendChild(canvas);
            spriteDiv.appendChild(label);
            spriteDiv.appendChild(downloadBtn);
            spritesContainer.appendChild(spriteDiv);
        }
        
        // Download a single sprite
        function downloadSprite(spriteData, row, col) {
            const link = document.createElement('a');
            link.href = spriteData.dataURL;
            link.download = `sprite_r${row}_c${col}.png`;
            link.click();
        }
        
        // Download all sprites as individual files
        function downloadAllSprites() {
            if (individualSprites.length === 0) return;
            
            // We'll use a timeout to give the browser a chance to handle each download
            let i = 0;
            function downloadNext() {
                if (i < individualSprites.length) {
                    const sprite = individualSprites[i];
                    downloadSprite(sprite, sprite.row, sprite.col);
                    i++;
                    // Schedule the next download
                    setTimeout(downloadNext, 100);
                } else {
                    statusElement.textContent = 'All sprites downloaded!';
                }
            }
            
            statusElement.textContent = 'Downloading sprites...';
            downloadNext();
        }
    </script>
</body>
</html>
