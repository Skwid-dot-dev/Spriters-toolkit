<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Sheet Splitter</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .panel {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        input, button {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        input[type="number"] {
            width: 80px;
        }
        input[type="file"] {
            padding: 3px; /* Minor padding for file inputs */
            margin-bottom: 5px; /* Add some space below file inputs */
        }
        button {
            background-color: #3498db;
            color: white;
            min-width: 100px; /* Ensure buttons have a decent minimum width */
            text-align: center;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: bold;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .preview-area {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .sprite-sheet-container {
            flex: 1;
            min-width: 300px;
            position: relative;
        }
        .sprites-container {
            flex: 1;
            min-width: 300px;
            max-height: 600px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .sprite-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #f5f5f5;
        }
        .sprite-item canvas {
            max-width: 100%;
            image-rendering: pixelated;
        }
        .sprite-item .sprite-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        #spriteSheetCanvas {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            image-rendering: pixelated;
        }
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .download-all {
            margin-top: 10px;
        }
        .hint {
            font-size: 14px;
            color: #666;
            font-style: italic;
            margin-top: 5px;
        }
        .status {
            font-weight: bold;
            margin-top: 10px;
            color: #27ae60;
        }
        /* Add to your existing CSS */
.animation-panel {
    margin-top: 20px;
}

#animationPreview {
    margin-top: 10px;
    border: 1px solid #ddd;
    background: #fff;
    image-rendering: pixelated;
    max-width: 100%;
    height: auto;
}

.color-palette {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 5px;
    margin-top: 10px;
    padding: 10px;
    background: #fff;
    border-radius: 4px;
    border: 1px solid #ddd;
}

.color-swatch {
    width: 30px;
    height: 30px;
    border: 1px solid #ddd;
    cursor: pointer;
    border-radius: 4px;
}

.transform-tools {
    display: flex;
    gap: 10px;
    margin-top: 10px;
    flex-wrap: wrap;
}

.color-tools {
    margin-top: 20px;
}

.selected-color {
    border: 2px solid #3498db;
}

/* Tab Navigation */
.tab-navigation {
    display: flex;
    gap: 10px; /* Space between tab buttons */
    margin-bottom: 20px; /* Space below the tabs */
    border-bottom: 2px solid #ddd; /* Separator line */
}

.tab-button {
    padding: 10px 20px;
    cursor: pointer;
    border: 1px solid transparent;
    border-bottom: none; /* Remove bottom border for buttons themselves */
    border-radius: 6px 6px 0 0; /* Rounded top corners */
    background-color: #f1f1f1; /* Default tab color */
    font-size: 16px;
    font-weight: bold;
    color: #555;
    transition: background-color 0.3s, color 0.3s;
}

.tab-button:hover {
    background-color: #e0e0e0; /* Lighter background on hover */
    color: #333;
}

.tab-button.active {
    background-color: #3498db; /* Active tab background color (same as other buttons) */
    color: white; /* Active tab text color */
    border-color: #ddd; /* Match the border of the navigation bar */
    border-bottom: 2px solid #3498db; /* Make it look like it's part of the content area */
    position: relative;
    top: 2px; /* Align with the content area border */
}

/* Tab Content */
.tab-content {
    display: none; /* Hide all tab content by default */
    padding: 20px;
    border: 1px solid #ddd;
    border-top: none; /* Avoid double border with tab navigation */
    border-radius: 0 0 8px 8px; /* Rounded bottom corners */
    background-color: #fff; /* White background for content */
}

.tab-content.active {
    display: block; /* Show active tab content */
}

/* Consistent h2 styling within tabs */
.tab-content h2 {
    color: #2c3e50;
    margin-top: 0; /* Remove default top margin if it's the first child */
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
}

/* Consistent h3 styling within tabs */
.tab-content h3 {
    color: #333; /* Slightly less prominent than h2 */
    margin-top: 15px; /* Space above h3 */
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid #f0f0f0; /* Lighter border for h3 */
}

/* Sprite Creator Styles */
.creator-controls {
    display: flex;
    gap: 15px;
    margin-bottom: 15px;
    align-items: flex-end;
}

.creator-workspace {
    display: flex;
    gap: 20px;
    margin-bottom: 15px;
}

#pixelCanvas {
    border: 1px solid #999;
    image-rendering: pixelated; /* Crucial for pixel art */
    cursor: crosshair;
}

.tools-palette {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.tool-button.active-tool {
    background-color: #3498db;
    color: white;
    border-color: #2980b9;
}

/* Re-use existing .color-palette and .color-swatch if suitable, or define: */
#colorPaletteCreator .color-swatch { /* Make sure this is specific enough */
    width: 25px;
    height: 25px;
    border: 1px solid #ccc;
    cursor: pointer;
    display: inline-block; /* Or use grid if preferred */
    margin: 2px;
}
#colorPaletteCreator .color-swatch.selected-creator-color {
    border: 2px solid #000000;
    box-shadow: 0 0 5px rgba(0,0,0,0.5);
}

.creator-actions {
    margin-top: 10px;
}

/* Sprite Stacker Styles */
.stacker-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-bottom: 15px;
}
.stacker-settings {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    align-items: flex-end;
    margin-bottom: 20px;
}
#spriteStackCanvas {
    border: 1px solid #999;
    background-color: #f0f0f0; /* Light gray background */
    image-rendering: pixelated;
    margin-top: 10px;
    max-width: 100%; /* Ensure it's responsive */
    height: auto;
}
        
    </style>
</head>
<body>
    <h1>Sprite Sheet Splitter</h1>
    <p>Upload a sprite sheet and split it into individual sprites by specifying the dimensions of each sprite.</p>

    <div class="tab-navigation">
        <button class="tab-button active" data-tab="spriteToolsTab">Sprite Tools</button>
        <button class="tab-button" data-tab="spriteCreatorTab">Sprite Creator</button>
        <button class="tab-button" data-tab="spriteStackerTab">Sprite Stacker</button>
    </div>

    <div id="spriteToolsTab" class="tab-content active">
        <div class="container">
            <div class="panel">
                <div class="controls">
                <div class="control-group">
                    <label for="spriteSheetInput">Upload Sprite Sheet:</label>
                    <input type="file" id="spriteSheetInput" accept="image/*">
                    <!-- Add after the existing preview panel -->

                </div>
                
                <div class="control-group">
                    <label for="spriteWidth">Sprite Width (px):</label>
                    <input type="number" id="spriteWidth" min="1" value="32">
                </div>
                
                <div class="control-group">
                    <label for="spriteHeight">Sprite Height (px):</label>
                    <input type="number" id="spriteHeight" min="1" value="32">
                </div>
                
                <div class="control-group">
                    <label for="spacing">Spacing (px):</label>
                    <input type="number" id="spacing" min="0" value="0">
                    <div class="hint">Space between sprites</div>
                </div>
                
                <div class="control-group">
                    <label for="padding">Padding (px):</label>
                    <input type="number" id="padding" min="0" value="0">
                    <div class="hint">Border inside each sprite</div>
                </div>
                
                <div class="control-group">
                    <label for="columns">Columns (optional):</label>
                    <input type="number" id="columns" min="0" value="0">
                    <div class="hint">Leave at 0 for auto-detection</div>
                </div>
                
                <div class="control-group">
                    <label>&nbsp;</label>
                    <button id="splitButton" disabled>Split Sprites</button>
                </div>
            </div>
            
            <div class="control-group">
                <label for="showGrid">
                    <input type="checkbox" id="showGrid" checked> Show Grid
                </label>
            </div>
        </div>
        
        <div class="panel">
            <h2>Preview</h2>
            <div class="preview-area">
                <div class="sprite-sheet-container">
                    <h3>Sprite Sheet</h3>
                    <canvas id="spriteSheetCanvas"></canvas>
                    <canvas id="gridOverlay" class="grid-overlay"></canvas>
                </div>

                <!-- Add after the existing preview panel -->
<div class="panel animation-panel">
    <h2>Animation Preview</h2>
    <div class="controls">
        <div class="control-group">
            <label for="frameStart">Start Frame:</label>
            <input type="number" id="frameStart" min="0" value="0">
        </div>
        <div class="control-group">
            <label for="frameEnd">End Frame:</label>
            <input type="number" id="frameEnd" min="0" value="0">
        </div>
        <div class="control-group">
            <label for="fps">FPS:</label>
            <input type="number" id="fps" min="1" value="12">
        </div>
        <button id="previewAnimation">Preview Animation</button>
        <button id="stopAnimation">Stop</button>
    </div>
    <canvas id="animationPreview"></canvas>
</div>

<div class="panel tools-panel">
    <h2>Sprite Tools</h2>
    <div class="transform-tools">
        <button id="flipH">Flip Horizontal</button>
        <button id="flipV">Flip Vertical</button>
        <button id="rotate90">Rotate 90°</button>
        <button id="rotate180">Rotate 180°</button>
        <button id="rotate270">Rotate 270°</button>
    </div>
    
    <div class="color-tools">
        <h3>Color Palette</h3>
        <button id="extractPalette">Extract Palette</button>
        <div id="colorPalette" class="color-palette"></div>
    </div>
</div>
                
                <div class="sprites-output">
                    <h3>Individual Sprites</h3>
                    <div id="spritesContainer" class="sprites-container">
                        <p>Split sprites will appear here</p>
                    </div>
                    <button id="downloadAllButton" class="download-all" disabled>Download All Sprites</button>
                    <div id="status" class="status"></div>
                </div>
            </div>
            </div>
        </div>
    </div>
    <div id="spriteCreatorTab" class="tab-content" style="display: none;">
   <h2>Sprite Creator</h2>
   <div class="creator-controls">
       <div class="control-group">
           <label for="canvasWidth">Canvas Width (px):</label>
           <input type="number" id="canvasWidth" value="32" min="8">
       </div>
       <div class="control-group">
           <label for="canvasHeight">Canvas Height (px):</label>
           <input type="number" id="canvasHeight" value="32" min="8">
       </div>
       <button id="setCanvasSize">Set Size & Clear</button>
   </div>

   <div class="creator-workspace">
       <canvas id="pixelCanvas"></canvas>
       <div class="tools-palette">
           <h3>Tools</h3>
           <button class="tool-button active-tool" data-tool="pencil">Pencil</button>
           <button class="tool-button" data-tool="eraser">Eraser</button>
           
           <h3>Color Palette</h3>
           <div id="colorPaletteCreator" class="color-palette">
               <!-- Colors will be added here by JS -->
           </div>
           <div>Selected Color: <span id="selectedColorDisplay" style="display: inline-block; width: 20px; height: 20px; border: 1px solid black;"></span></div>
       </div>
   </div>
   <div class="creator-actions">
       <button id="downloadCreatedSprite">Download Sprite</button>
   </div>
</div>
    <div id="spriteStackerTab" class="tab-content" style="display: none;">
   <h2>Sprite Stacker (2.5D Preview)</h2>
   <div class="stacker-controls">
       <div class="control-group">
           <label for="stackerSpriteSheetInput">Upload Sprite Sheet:</label>
           <input type="file" id="stackerSpriteSheetInput" accept="image/*">
       </div>
       <div class="control-group">
           <label for="stackerSpriteWidth">Sprite Width (px):</label>
           <input type="number" id="stackerSpriteWidth" min="1" value="32">
       </div>
       <div class="control-group">
           <label for="stackerSpriteHeight">Sprite Height (px):</label>
           <input type="number" id="stackerSpriteHeight" min="1" value="32">
       </div>
       <div class="control-group">
           <label for="stackerSpacing">Spacing (px):</label>
           <input type="number" id="stackerSpacing" min="0" value="0">
       </div>
       <div class="control-group">
           <label for="stackerPadding">Padding (px):</label>
           <input type="number" id="stackerPadding" min="0" value="0">
       </div>
       <div class="control-group">
           <label for="stackerColumns">Columns (optional):</label>
           <input type="number" id="stackerColumns" min="0" value="0">
       </div>
   </div>
   <div class="stacker-settings">
        <div class="control-group">
           <label for="layerOffset">Vertical Layer Offset:</label>
           <input type="number" id="layerOffset" value="5" min="-20" max="50">
        </div>
        <div class="control-group">
            <label for="horizontalOffsetFactor">Horizontal Offset Factor (relative to vertical):</label>
            <input type="number" id="horizontalOffsetFactor" value="0.5" step="0.1" min="-2" max="2">
         </div>
       <button id="processSpriteStackButton" disabled>Process and Stack Sprites</button>
   </div>

   <canvas id="spriteStackCanvas"></canvas>
</div>

    <script>
// Tab Switching Logic
document.addEventListener('DOMContentLoaded', () => {
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');

    // Function to switch tabs
    function openTab(event, tabId) {
        // Hide all tab content
        tabContents.forEach(content => {
            content.style.display = 'none';
            content.classList.remove('active');
        });

        // Deactivate all tab buttons
        tabButtons.forEach(button => {
            button.classList.remove('active');
        });

        // Show the target tab content
        const targetContent = document.getElementById(tabId);
        if (targetContent) {
            targetContent.style.display = 'block';
            targetContent.classList.add('active');
        }

        // Activate the clicked tab button
        if (event && event.currentTarget) {
            event.currentTarget.classList.add('active');
        } else {
            // Fallback for initial load if needed, though CSS handles it
            const currentButton = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
            if (currentButton) {
                currentButton.classList.add('active');
            }
        }
    }

    // Add click event listeners to tab buttons
    tabButtons.forEach(button => {
        button.addEventListener('click', (event) => {
            const tabId = event.currentTarget.getAttribute('data-tab');
            openTab(event, tabId);
        });
    });

    // Ensure the initially active tab (Sprite Tools) is correctly displayed.
    // The HTML/CSS already sets the first tab as active.
    // This JS logic will take over for subsequent clicks.
    // If no tab is explicitly set to active in HTML, this could be used to default:
    // const initialActiveButton = document.querySelector('.tab-button.active');
    // if (initialActiveButton) {
    //     openTab(null, initialActiveButton.getAttribute('data-tab'));
    // } else if (tabButtons.length > 0) {
    //     // Or default to the first tab if none are marked active
    //     tabButtons[0].click(); // Simulate a click to open it
    // }
});
// End of Tab Switching Logic

// Sprite Creator Logic
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('pixelCanvas');
    if (!canvas) return; // Only run if the sprite creator tab is present
    const ctx = canvas.getContext('2d');

    const canvasWidthInput = document.getElementById('canvasWidth');
    const canvasHeightInput = document.getElementById('canvasHeight');
    const setSizeButton = document.getElementById('setCanvasSize');
    const downloadButton = document.getElementById('downloadCreatedSprite');
    const toolButtons = document.querySelectorAll('.tool-button');
    const colorPaletteContainer = document.getElementById('colorPaletteCreator');
    const selectedColorDisplay = document.getElementById('selectedColorDisplay');

    let currentTool = 'pencil'; // 'pencil' or 'eraser'
    let selectedColor = '#000000'; // Default to black
    let isDrawing = false;
    let pixelSize = 10; // How large each "pixel" on the canvas appears

    const defaultPalette = [
        '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF',
        '#FFFF00', '#FF00FF', '#00FFFF', '#808080', '#C0C0C0',
        '#FFA500', '#A52A2A', '#800080', '#008000', '#800000', '#000080'
    ];

    function initializeCanvas(width, height) {
        canvas.width = width * pixelSize;
        canvas.height = height * pixelSize;
        ctx.fillStyle = '#FFFFFF'; // Default background
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid(width, height);
        // Store actual pixel data in a separate array if needed for more complex ops,
        // for now, we'll read from canvas when needed or draw directly.
    }

    function drawGrid(gridWidth, gridHeight) {
        ctx.strokeStyle = '#DDDDDD';
        ctx.beginPath();
        for (let x = 0; x <= canvas.width; x += pixelSize) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
        }
        for (let y = 0; y <= canvas.height; y += pixelSize) {
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();
    }
    
    function populatePalette() {
         colorPaletteContainer.innerHTML = '';
         defaultPalette.forEach(color => {
             const swatch = document.createElement('div');
             swatch.className = 'color-swatch';
             swatch.style.backgroundColor = color;
             swatch.addEventListener('click', () => {
                 selectedColor = color;
                 selectedColorDisplay.style.backgroundColor = color;
                 document.querySelectorAll('#colorPaletteCreator .color-swatch').forEach(s => s.classList.remove('selected-creator-color'));
                 swatch.classList.add('selected-creator-color');
             });
             colorPaletteContainer.appendChild(swatch);
         });
         // Select the first color by default
         if (defaultPalette.length > 0) {
             const firstSwatch = colorPaletteContainer.querySelector('.color-swatch');
             if (firstSwatch) firstSwatch.click();
         }
    }

    setSizeButton.addEventListener('click', () => {
        const newWidth = parseInt(canvasWidthInput.value);
        const newHeight = parseInt(canvasHeightInput.value);
        if (newWidth >= 8 && newHeight >= 8) {
            initializeCanvas(newWidth, newHeight);
        } else {
            alert("Width and Height must be at least 8.");
        }
    });

    toolButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            toolButtons.forEach(btn => btn.classList.remove('active-tool'));
            e.currentTarget.classList.add('active-tool');
            currentTool = e.currentTarget.getAttribute('data-tool');
        });
    });

    function draw(event) {
        if (!isDrawing) return;
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((event.clientX - rect.left) / pixelSize);
        const y = Math.floor((event.clientY - rect.top) / pixelSize);
        
        const gridWidth = parseInt(canvasWidthInput.value);
        const gridHeight = parseInt(canvasHeightInput.value);

        if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return;

        ctx.fillStyle = currentTool === 'pencil' ? selectedColor : '#FFFFFF'; // Eraser uses white
        if (currentTool === 'eraser') {
             // Clear the rect then redraw grid line
             ctx.clearRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
             ctx.fillStyle = '#FFFFFF'; // Ensure eraser background is white before potentially redrawing grid
             ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);

             // Redraw specific grid lines for the erased cell
             ctx.strokeStyle = '#DDDDDD';
             ctx.beginPath();
             // Vertical line
             ctx.moveTo((x + 1) * pixelSize, y * pixelSize);
             ctx.lineTo((x + 1) * pixelSize, (y + 1) * pixelSize);
             // Horizontal line
             ctx.moveTo(x * pixelSize, (y + 1) * pixelSize);
             ctx.lineTo((x + 1) * pixelSize, (y + 1) * pixelSize);
             // If not on the edge, also draw the top and left lines of cell
             if (x > 0) {
                 ctx.moveTo(x * pixelSize, y * pixelSize);
                 ctx.lineTo(x * pixelSize, (y+1) * pixelSize);
             }
              if (y > 0) {
                 ctx.moveTo(x * pixelSize, y * pixelSize);
                 ctx.lineTo((x+1) * pixelSize, y * pixelSize);
             }
             ctx.stroke();

        } else {
            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
        }
    }

    canvas.addEventListener('mousedown', (e) => {
        isDrawing = true;
        draw(e); // Draw on click as well
    });
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', () => isDrawing = false);
    canvas.addEventListener('mouseleave', () => isDrawing = false); // Stop drawing if mouse leaves canvas

    downloadButton.addEventListener('click', () => {
        // Create a temporary canvas to draw the actual pixel data without grid/scaling
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        const finalWidth = parseInt(canvasWidthInput.value);
        const finalHeight = parseInt(canvasHeightInput.value);
        tempCanvas.width = finalWidth;
        tempCanvas.height = finalHeight;

        for (let i = 0; i < finalWidth; i++) {
            for (let j = 0; j < finalHeight; j++) {
                const imgData = ctx.getImageData(i * pixelSize, j * pixelSize, 1, 1);
                // Check if the pixel is transparent (or white, if that's your erase color)
                // For simplicity, if erased cells are pure white and non-distinguishable from an intentionally white pixel,
                // this direct copy is fine. If eraser truly makes transparent pixels, getImageData is right.
                tempCtx.putImageData(imgData, i, j);
            }
        }
        
        const dataURL = tempCanvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'sprite.png';
        link.href = dataURL;
        link.click();
    });

    // Initial setup
    initializeCanvas(parseInt(canvasWidthInput.value), parseInt(canvasHeightInput.value));
    populatePalette();
});
// End of Sprite Creator Logic

// Sprite Stacker Logic
document.addEventListener('DOMContentLoaded', () => {
    const stackerSpriteSheetInput = document.getElementById('stackerSpriteSheetInput');
    if (!stackerSpriteSheetInput) return; // Only run if this tab's elements are present

    const stackerSpriteWidthInput = document.getElementById('stackerSpriteWidth');
    const stackerSpriteHeightInput = document.getElementById('stackerSpriteHeight');
    const stackerSpacingInput = document.getElementById('stackerSpacing');
    const stackerPaddingInput = document.getElementById('stackerPadding');
    const stackerColumnsInput = document.getElementById('stackerColumns');
    const processButton = document.getElementById('processSpriteStackButton');
    const stackCanvas = document.getElementById('spriteStackCanvas');
    const stackCtx = stackCanvas.getContext('2d');
    const layerOffsetInput = document.getElementById('layerOffset');
    const horizontalOffsetFactorInput = document.getElementById('horizontalOffsetFactor');

    let loadedSheetImage = null;
    let individualStackedSprites = [];

    stackerSpriteSheetInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                loadedSheetImage = img;
                processButton.disabled = false;
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    processButton.addEventListener('click', () => { // Corrected arrow function
        if (!loadedSheetImage) {
            alert("Please upload a sprite sheet first.");
            return;
        }
        extractSpritesForStacking();
        renderStackedSprites();
    });
    
    [layerOffsetInput, horizontalOffsetFactorInput].forEach(input => {
        input.addEventListener('change', () => {
            if (individualStackedSprites.length > 0) {
                renderStackedSprites();
            }
        });
    });

    function extractSpritesForStacking() {
        const spriteWidth = parseInt(stackerSpriteWidthInput.value) || 32;
        const spriteHeight = parseInt(stackerSpriteHeightInput.value) || 32;
        const spacing = parseInt(stackerSpacingInput.value) || 0;
        const padding = parseInt(stackerPaddingInput.value) || 0;
        const specifiedColumns = parseInt(stackerColumnsInput.value) || 0;

        const columns = specifiedColumns || Math.floor(loadedSheetImage.width / (spriteWidth + spacing));
        const rows = Math.floor(loadedSheetImage.height / (spriteHeight + spacing));

        individualStackedSprites = [];
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        tempCanvas.width = spriteWidth - 2 * padding;
        tempCanvas.height = spriteHeight - 2 * padding;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < columns; col++) {
                const x = col * (spriteWidth + spacing) + padding;
                const y = row * (spriteHeight + spacing) + padding;
                const effectiveWidth = spriteWidth - 2 * padding;
                const effectiveHeight = spriteHeight - 2 * padding;

                if (x + effectiveWidth > loadedSheetImage.width || y + effectiveHeight > loadedSheetImage.height) {
                    continue;
                }
                
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(
                    loadedSheetImage,
                    x, y, effectiveWidth, effectiveHeight,
                    0, 0, tempCanvas.width, tempCanvas.height
                );
                
                const spriteImage = new Image();
                spriteImage.src = tempCanvas.toDataURL('image/png');
                individualStackedSprites.push(spriteImage); 
            }
        }
    }

    function renderStackedSprites() {
        if (individualStackedSprites.length === 0) return;

        const layerOffset = parseInt(layerOffsetInput.value);
        const horizontalOffsetFactor = parseFloat(horizontalOffsetFactorInput.value);
        
        // Wait for all images to load to get accurate dimensions
        let imagesLoaded = 0;
        individualStackedSprites.forEach(img => {
            if (img.complete) {
                imagesLoaded++;
            } else {
                img.onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === individualStackedSprites.length) {
                        performRender();
                    }
                };
                img.onerror = () => { // Handle potential errors
                    imagesLoaded++; 
                    console.error("Error loading sprite for stacking calculation.");
                    if (imagesLoaded === individualStackedSprites.length) {
                        performRender(); // Still try to render with what's available or default sizes
                    }
                };
            }
        });

        if (imagesLoaded === individualStackedSprites.length) {
            performRender();
        }

        function performRender() {
            const baseSpriteWidth = individualStackedSprites[0].naturalWidth || parseInt(stackerSpriteWidthInput.value); // Fallback
            const baseSpriteHeight = individualStackedSprites[0].naturalHeight || parseInt(stackerSpriteHeightInput.value); // Fallback

            let minX = 0, maxX = baseSpriteWidth;
            let minY = 0, maxY = baseSpriteHeight;

            for (let i = 1; i < individualStackedSprites.length; i++) {
                const currentXOffset = i * layerOffset * horizontalOffsetFactor;
                const currentYOffset = i * layerOffset; 
                
                maxX = Math.max(maxX, currentXOffset + baseSpriteWidth);
                maxY = Math.max(maxY, currentYOffset + baseSpriteHeight);
                minX = Math.min(minX, currentXOffset);
                minY = Math.min(minY, currentYOffset);
            }
            
            stackCanvas.width = maxX - minX;
            stackCanvas.height = maxY - minY;
            stackCtx.clearRect(0, 0, stackCanvas.width, stackCanvas.height);

            const drawingOriginX = -minX;
            const drawingOriginY = -minY;

            let loadedCount = 0;
            const totalSprites = individualStackedSprites.length;

            individualStackedSprites.forEach((spriteImg) => { // Removed index from here as it's not used directly
                if (spriteImg.complete && spriteImg.naturalWidth > 0) {
                    loadedCount++;
                } else if (!spriteImg.complete) { // Only attach onload if not already loaded
                    spriteImg.onload = () => {
                        loadedCount++;
                        if (loadedCount === totalSprites) {
                            drawAllLayers(drawingOriginX, drawingOriginY, layerOffset, horizontalOffsetFactor);
                        }
                    };
                    spriteImg.onerror = () => { 
                        loadedCount++; 
                        console.error("Error loading sprite for stacking render.");
                        if (loadedCount === totalSprites) {
                            drawAllLayers(drawingOriginX, drawingOriginY, layerOffset, horizontalOffsetFactor);
                        }
                    };
                } else { // Image is complete but naturalWidth is 0 (error state)
                     loadedCount++; 
                     console.error("Skipping invalid sprite in stacking render.");
                }
            });

            if (loadedCount === totalSprites) {
                drawAllLayers(drawingOriginX, drawingOriginY, layerOffset, horizontalOffsetFactor);
            }
        }
    }

    function drawAllLayers(drawingOriginX, drawingOriginY, layerOffset, horizontalOffsetFactor) {
        stackCtx.clearRect(0, 0, stackCanvas.width, stackCanvas.height); 
        individualStackedSprites.forEach((spriteImg, index) => {
            if (spriteImg.complete && spriteImg.naturalWidth > 0) { 
                const x = drawingOriginX + (index * layerOffset * horizontalOffsetFactor);
                const y = drawingOriginY + (index * layerOffset);
                stackCtx.drawImage(spriteImg, x, y);
            }
        });
    }
});
// End of Sprite Stacker Logic

// Dummy SpriteTransformer to prevent errors until actual implementation is available
const SpriteTransformer = {
    flip: function(canvas, horizontal) {
        console.warn("SpriteTransformer.flip is not fully implemented. Canvas data:", canvas, "Horizontal:", horizontal);
        // Return a new canvas or modify in place, depending on expected behavior.
        // For now, return a dummy canvas to avoid breaking further chaining if any.
        const newCanvas = document.createElement('canvas');
        newCanvas.width = canvas.width;
        newCanvas.height = canvas.height;
        const newCtx = newCanvas.getContext('2d');
        newCtx.drawImage(canvas,0,0); // just copy for now
        if (horizontal) {
            newCtx.translate(newCanvas.width, 0);
            newCtx.scale(-1, 1);
            newCtx.drawImage(canvas, 0, 0);
        } else {
            newCtx.translate(0, newCanvas.height);
            newCtx.scale(1, -1);
            newCtx.drawImage(canvas, 0, 0);
        }
        console.log("Dummy flip performed. Actual flip logic needed.");
        return newCanvas; // Or return the modified input canvas
    },
    rotate: function(canvas, degrees) {
        console.warn("SpriteTransformer.rotate is not fully implemented. Canvas data:", canvas, "Degrees:", degrees);
        const newCanvas = document.createElement('canvas');
        const newCtx = newCanvas.getContext('2d');
        // Basic rotation logic (may need adjustment for centering)
        if (degrees === 90 || degrees === 270) {
            newCanvas.width = canvas.height;
            newCanvas.height = canvas.width;
        } else { // 180
            newCanvas.width = canvas.width;
            newCanvas.height = canvas.height;
        }
        newCtx.translate(newCanvas.width / 2, newCanvas.height / 2);
        newCtx.rotate(degrees * Math.PI / 180);
        newCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
        console.log("Dummy rotation performed. Actual rotation logic needed.");
        return newCanvas;
    }
};
// End of Dummy SpriteTransformer

        const spriteSheetInput = document.getElementById('spriteSheetInput');
        const spriteWidthInput = document.getElementById('spriteWidth');
        const spriteHeightInput = document.getElementById('spriteHeight');
        const spacingInput = document.getElementById('spacing');
        const paddingInput = document.getElementById('padding');
        const columnsInput = document.getElementById('columns');
        const showGridCheckbox = document.getElementById('showGrid');
        const splitButton = document.getElementById('splitButton');
        const downloadAllButton = document.getElementById('downloadAllButton');
        const spriteSheetCanvas = document.getElementById('spriteSheetCanvas');
        const gridOverlay = document.getElementById('gridOverlay');
        const spritesContainer = document.getElementById('spritesContainer');
        const statusElement = document.getElementById('status');
        
        let spriteSheet = null;
        let individualSprites = [];
        // Add these class definitions at the top of your script
class PaletteManager {
    constructor() {
        this.colors = [];
        this.maxColors = 32;
        this.selectedColor = null;
    }
    
    extractPalette(imageData) {
        const colorMap = new Map();
        
        for(let i = 0; i < imageData.data.length; i += 4) {
            const r = imageData.data[i];
            const g = imageData.data[i + 1];
            const b = imageData.data[i + 2];
            const a = imageData.data[i + 3];
            const colorKey = `rgba(${r},${g},${b},${a})`;
            
            colorMap.set(colorKey, (colorMap.get(colorKey) || 0) + 1);
        }
        
        // Sort colors by frequency
        this.colors = Array.from(colorMap.entries())
            .sort((a, b) => b[1] - a[1])
            .map(([color]) => color)
            .slice(0, this.maxColors);
            
        return this.colors;
    }
    
    renderPalette() {
        const palette = document.getElementById('colorPalette');
        palette.innerHTML = '';
        
        this.colors.forEach(color => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = color;
            swatch.addEventListener('click', () => this.selectColor(color, swatch));
            palette.appendChild(swatch);
        });
    }
    
    selectColor(color, swatch) {
        this.selectedColor = color;
        document.querySelectorAll('.color-swatch').forEach(s => 
            s.classList.remove('selected-color'));
        swatch.classList.add('selected-color');
    }
}

class AnimationPreview {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.frames = [];
        this.currentFrame = 0;
        this.isPlaying = false;
        this.fps = 12;
        this.animationId = null;
    }
    
    setFrames(frames) {
        this.frames = frames;
        this.currentFrame = 0;
        this.canvas.width = frames[0].width;
        this.canvas.height = frames[0].height;
    }
    
    play() {
        if (this.frames.length === 0) return;
        
        this.isPlaying = true;
        let lastTime = 0;
        const frameInterval = 1000 / this.fps;
        
        const animate = (timestamp) => {
            if (!this.isPlaying) return;
            
            if (timestamp - lastTime >= frameInterval) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.frames[this.currentFrame], 0, 0);
                
                this.currentFrame = (this.currentFrame + 1) % this.frames.length;
                lastTime = timestamp;
            }
            
            this.animationId = requestAnimationFrame(animate);
        };
        
        this.animationId = requestAnimationFrame(animate);
    }
    
    stop() {
        this.isPlaying = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        this.currentFrame = 0;
        if (this.frames.length > 0) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(this.frames[0], 0, 0);
        }
    }
}

// Initialize new components
const paletteManager = new PaletteManager();
const animationPreview = new AnimationPreview(document.getElementById('animationPreview'));

// Add event listeners for new functionality
document.getElementById('extractPalette').addEventListener('click', () => {
    if (!spriteSheet) return;
    
    const ctx = spriteSheetCanvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, spriteSheetCanvas.width, spriteSheetCanvas.height);
    paletteManager.extractPalette(imageData);
    paletteManager.renderPalette();
});

document.getElementById('previewAnimation').addEventListener('click', () => {
    const startFrame = parseInt(document.getElementById('frameStart').value);
    const endFrame = parseInt(document.getElementById('frameEnd').value);
    const fps = parseInt(document.getElementById('fps').value);
    
    if (startFrame >= 0 && endFrame < individualSprites.length && startFrame <= endFrame) {
        const frames = individualSprites
            .slice(startFrame, endFrame + 1)
            .map(sprite => {
                const img = new Image();
                img.src = sprite.dataURL;
                return img;
            });
            
        animationPreview.fps = fps;
        animationPreview.setFrames(frames);
        animationPreview.play();
    }
});

document.getElementById('stopAnimation').addEventListener('click', () => {
    animationPreview.stop();
});

// Transform tools event listeners
document.getElementById('flipH').addEventListener('click', () => {
    if (!spriteSheet) return;
    const flipped = SpriteTransformer.flip(spriteSheetCanvas, true);
    spriteSheetCanvas.getContext('2d').drawImage(flipped, 0, 0);
    drawGrid();
});

document.getElementById('flipV').addEventListener('click', () => {
    if (!spriteSheet) return;
    const flipped = SpriteTransformer.flip(spriteSheetCanvas, false);
    spriteSheetCanvas.getContext('2d').drawImage(flipped, 0, 0);
    drawGrid();
});

['90', '180', '270'].forEach(degrees => {
    document.getElementById(`rotate${degrees}`).addEventListener('click', () => {
        if (!spriteSheet) return;
        const rotated = SpriteTransformer.rotate(spriteSheetCanvas, parseInt(degrees));
        spriteSheetCanvas.getContext('2d').drawImage(rotated, 0, 0);
        drawGrid();
    });
});
        
        
        // Handle sprite sheet upload
        spriteSheetInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    spriteSheet = img;
                    renderSpriteSheet();
                    splitButton.disabled = false;
                    showGridCheckbox.checked = true;
                    drawGrid();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
        
        // Update grid when dimensions change
        [spriteWidthInput, spriteHeightInput, spacingInput, paddingInput, columnsInput].forEach(input => {
            input.addEventListener('change', drawGrid);
        });
        
        // Toggle grid visibility
        showGridCheckbox.addEventListener('change', function() {
            gridOverlay.style.display = this.checked ? 'block' : 'none';
        });
        
        // Split the sprite sheet into individual sprites
        splitButton.addEventListener('click', splitSpriteSheet);
        
        // Download all sprites as ZIP
        downloadAllButton.addEventListener('click', downloadAllSprites);
        
        // Render the sprite sheet on canvas
        function renderSpriteSheet() {
            if (!spriteSheet) return;
            
            const ctx = spriteSheetCanvas.getContext('2d');
            spriteSheetCanvas.width = spriteSheet.width;
            spriteSheetCanvas.height = spriteSheet.height;
            ctx.clearRect(0, 0, spriteSheetCanvas.width, spriteSheetCanvas.height);
            ctx.drawImage(spriteSheet, 0, 0);
            
            // Also resize the grid overlay
            gridOverlay.width = spriteSheet.width;
            gridOverlay.height = spriteSheet.height;
        }
        
        // Draw the grid overlay
        function drawGrid() {
            if (!spriteSheet) return;
            
            const spriteWidth = parseInt(spriteWidthInput.value) || 32;
            const spriteHeight = parseInt(spriteHeightInput.value) || 32;
            const spacing = parseInt(spacingInput.value) || 0;
            const padding = parseInt(paddingInput.value) || 0;
            const specifiedColumns = parseInt(columnsInput.value) || 0;
            
            const ctx = gridOverlay.getContext('2d');
            ctx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);
            
            // Calculate columns if not specified
            const columns = specifiedColumns || Math.floor(spriteSheet.width / (spriteWidth + spacing));
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            
            // Draw horizontal lines
            for (let y = 0; y <= spriteSheet.height; y += spriteHeight + spacing) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(spriteSheet.width, y);
                ctx.stroke();
            }
            
            // Draw vertical lines
            if (specifiedColumns > 0) {
                // If columns are specified, draw that many columns evenly spaced
                for (let x = 0; x <= spriteSheet.width; x += (spriteSheet.width / columns)) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, spriteSheet.height);
                    ctx.stroke();
                }
            } else {
                // Otherwise draw lines based on sprite width + spacing
                for (let x = 0; x <= spriteSheet.width; x += spriteWidth + spacing) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, spriteSheet.height);
                    ctx.stroke();
                }
            }
            
            // If padding is specified, draw inner rectangles
            if (padding > 0) {
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
                
                const rows = Math.floor(spriteSheet.height / (spriteHeight + spacing));
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < columns; col++) {
                        const x = col * (spriteWidth + spacing) + padding;
                        const y = row * (spriteHeight + spacing) + padding;
                        const innerWidth = spriteWidth - 2 * padding;
                        const innerHeight = spriteHeight - 2 * padding;
                        
                        ctx.strokeRect(x, y, innerWidth, innerHeight);
                    }
                }
            }
        }
        
        // Split the sprite sheet into individual sprites
        function splitSpriteSheet() {
            if (!spriteSheet) return;
            
            const spriteWidth = parseInt(spriteWidthInput.value) || 32;
            const spriteHeight = parseInt(spriteHeightInput.value) || 32;
            const spacing = parseInt(spacingInput.value) || 0;
            const padding = parseInt(paddingInput.value) || 0;
            const specifiedColumns = parseInt(columnsInput.value) || 0;
            
            // Calculate columns and rows
            const columns = specifiedColumns || Math.floor(spriteSheet.width / (spriteWidth + spacing));
            const rows = Math.floor(spriteSheet.height / (spriteHeight + spacing));
            
            // Clear previous sprites
            individualSprites = [];
            spritesContainer.innerHTML = '';
            
            // Create temporary canvas for extraction
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = spriteWidth - 2 * padding;
            tempCanvas.height = spriteHeight - 2 * padding;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Extract each sprite
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < columns; col++) {
                    const x = col * (spriteWidth + spacing) + padding;
                    const y = row * (spriteHeight + spacing) + padding;
                    const effectiveWidth = spriteWidth - 2 * padding;
                    const effectiveHeight = spriteHeight - 2 * padding;
                    
                    // Skip if outside image bounds
                    if (x + effectiveWidth > spriteSheet.width || y + effectiveHeight > spriteSheet.height) {
                        continue;
                    }
                    
                    // Extract sprite
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(
                        spriteSheet, 
                        x, y, effectiveWidth, effectiveHeight,
                        0, 0, tempCanvas.width, tempCanvas.height
                    );
                    
                    // Create sprite data
                    const spriteData = {
                        row,
                        col,
                        dataURL: tempCanvas.toDataURL('image/png'),
                        width: effectiveWidth,
                        height: effectiveHeight
                    };
                    
                    individualSprites.push(spriteData);
                    
                    // Create sprite preview
                    createSpritePreview(spriteData, row, col);
                }
            }
            
            // Enable download button
            downloadAllButton.disabled = individualSprites.length === 0;
            
            // Show status
            statusElement.textContent = `${individualSprites.length} sprites extracted`;
        }
        
        // Create and display a preview for a single sprite
        function createSpritePreview(spriteData, row, col) {
            const spriteDiv = document.createElement('div');
            spriteDiv.className = 'sprite-item';
            
            // Create canvas for sprite
            const canvas = document.createElement('canvas');
            canvas.width = spriteData.width;
            canvas.height = spriteData.height;
            const ctx = canvas.getContext('2d');
            
            // Draw sprite
            const img = new Image();
            img.onload = function() {
                ctx.drawImage(img, 0, 0);
            };
            img.src = spriteData.dataURL;
            
            // Add sprite index label
            const label = document.createElement('div');
            label.className = 'sprite-label';
            label.textContent = `Row ${row}, Col ${col}`;
            
            // Add download button for individual sprite
            const downloadBtn = document.createElement('button');
            downloadBtn.textContent = 'Download';
            downloadBtn.style.fontSize = '12px';
            downloadBtn.style.padding = '3px 6px';
            downloadBtn.style.marginTop = '5px';
            downloadBtn.addEventListener('click', () => {
                downloadSprite(spriteData, row, col);
            });
            
            spriteDiv.appendChild(canvas);
            spriteDiv.appendChild(label);
            spriteDiv.appendChild(downloadBtn);
            spritesContainer.appendChild(spriteDiv);
        }
        
        // Download a single sprite
        function downloadSprite(spriteData, row, col) {
            const link = document.createElement('a');
            link.href = spriteData.dataURL;
            link.download = `sprite_r${row}_c${col}.png`;
            link.click();
        }
        
        // Download all sprites as individual files
        function downloadAllSprites() {
            if (individualSprites.length === 0) return;
            
            // We'll use a timeout to give the browser a chance to handle each download
            let i = 0;
            function downloadNext() {
                if (i < individualSprites.length) {
                    const sprite = individualSprites[i];
                    downloadSprite(sprite, sprite.row, sprite.col);
                    i++;
                    // Schedule the next download
                    setTimeout(downloadNext, 100);
                } else {
                    statusElement.textContent = 'All sprites downloaded!';
                }
            }
            
            statusElement.textContent = 'Downloading sprites...';
            downloadNext();
        }
    </script>
</body>
</html>
